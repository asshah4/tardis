% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_hypothesis.R
\name{tar_hypothesis}
\alias{tar_hypothesis}
\title{Create a hypothesis to be tested}
\usage{
tar_hypothesis(
  name,
  formula,
  combination = "direct",
  ...,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue")
)
}
\arguments{
\item{name}{Name of target}

\item{formula}{Formula showing relationship of outcomes and predictors, and
is essentially the hypothesis. It allows for complex formulas e.g. multiple
predictors, multiple exposures, and multiple covariates, that can be
organized into individual formulas based on additional modifiers. Each RHS
term of the formula is considered an outcome variable, and is analyzed as a
single outcome. Each LHS term is consider a predictor, and can be modified
as below:
\itemize{
\item \code{exp()} is placed around a term to define as an independent exposure,
which will be placed in separate formulas from any other term marked as an
exposure
\item \code{cov()} is placed around a term for any predictors that should be
maintained/fixed in all models, which can include complex terms, such as
mixed effects
}

Of note, these formula modifiers do not apply to \code{htest} objects yet.

For example, the equation below describes two independent exposures "x1"
and "x2" that should be conditionally regressed for every level of "z"

\deqn{y ~ exp(x1) + exp(x2) + x3 + x4 + cov((1 | z))}}

\item{combination}{The building pattern for how to put together the overall
plan. It defines variable relationships that will be used. The options for
the \code{combination} currently include:
\itemize{
\item \code{direct} will define the relationship as y ~ x
\item \code{sequential} will define the relationship as y ~ x1, y ~ x1 + x2
\item \code{parallel} will define the relationship as y ~ x1, y ~ x2
}}

\item{tidy_eval}{Logical, whether to enable tidy evaluation
when interpreting \code{command} and \code{pattern}. If \code{TRUE}, you can use the
"bang-bang" operator \verb{!!} to programmatically insert
the values of global objects.}

\item{packages}{Character vector of packages to load right before
the target builds. Use \code{tar_option_set()} to set packages
globally for all subsequent targets you define.}

\item{library}{Character vector of library paths to try
when loading \code{packages}.}

\item{format}{Optional storage format for the target's return value.
With the exception of \code{format = "file"}, each target
gets a file in \verb{_targets/objects}, and each format is a different
way to save and load this file. See the "Storage formats" section
for a detailed list of possible data storage formats.}

\item{error}{Character of length 1, what to do if the target
stops and throws an error. Options:
\itemize{
\item \code{"stop"}: the whole pipeline stops and throws an error.
\item \code{"continue"}: the whole pipeline keeps going.
\item \code{"abridge"}: any currently running targets keep running,
but no new targets launch after that.
(Visit \url{https://books.ropensci.org/targets/debugging.html}
to learn how to debug targets using saved workspaces.)
}}

\item{memory}{Character of length 1, memory strategy.
If \code{"persistent"}, the target stays in memory
until the end of the pipeline (unless \code{storage} is \code{"worker"},
in which case \code{targets} unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If \code{"transient"}, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files such as \code{format = "aws_file"},
this memory strategy applies to
temporary local copies of the file in \verb{_targets/scratch/"}:
\code{"persistent"} means they remain until the end of the pipeline,
and \code{"transient"} means they get deleted from the file system
as soon as possible. The former conserves bandwidth,
and the latter conserves local storage.}

\item{garbage_collection}{Logical, whether to run \code{base::gc()}
just before the target runs.}

\item{deployment}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}. If \code{"worker"},
the target builds on a parallel worker. If \code{"main"},
the target builds on the host machine / process managing the pipeline.}

\item{priority}{Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get built earlier
(and polled earlier in \code{\link[targets:tar_make_future]{tar_make_future()}}).}

\item{resources}{Object returned by \code{tar_resources()}
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of \code{targets}.
See \code{tar_resources()} for details.}

\item{storage}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"main"}, the target's return value is sent back to the
host machine and saved locally. If \code{"worker"}, the worker
saves the value.}

\item{retrieval}{Character of length 1, only relevant to
\code{\link[targets:tar_make_clustermq]{tar_make_clustermq()}} and \code{\link[targets:tar_make_future]{tar_make_future()}}.
If \code{"main"}, the target's dependencies are loaded on the host machine
and sent to the worker before the target builds.
If \code{"worker"}, the worker loads the targets dependencies.}

\item{cue}{An optional object from \code{tar_cue()} to customize the
rules that decide whether the target is up to date.}
}
\value{
A list of target objects
}
\description{
\code{tar_hypothesis()} is a shorthand to create a number of related hypothesis
that are related, usually built in a causal/epidemiology framework.
}
\details{
\code{tar_hypothesis()} is a wrapper function to help create multiple
target models that share a outcome and exposure, with prespecified patterns
for adjustment.
}
